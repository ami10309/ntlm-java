/*
 * $Id: $
 */
package org.microsoft.security.ntlm.impl;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

import static org.microsoft.security.ntlm.impl.Algorithms.ASCII_ENCODING;
import static org.microsoft.security.ntlm.impl.Algorithms.UNICODE_ENCODING;
import static org.microsoft.security.ntlm.impl.Algorithms.calculateMD4;

/**
 *
 * How NTLM version is detected: http://davenport.sourceforge.net/ntlm.html#ntlmVersion2
 * Also NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is used to negotiate
 *
 * @author <a href="http://profiles.google.com/109977706462274286343">Veritatem Quaeres</a>
 * @version $Revision: $
 */
public class NtlmV1Routines {

    private static final byte[] MAGIC_KGS_CONSTANT = "KGS!@#$%".getBytes(ASCII_ENCODING);

    private static final SecretKeyFactory DES_KEYFACTORY;
    private static final Cipher DES_CIPHER;

    static {
        try {
            DES_KEYFACTORY = SecretKeyFactory.getInstance ("DES");
            DES_CIPHER = Cipher.getInstance ("DES/ECB/NoPadding");
        } catch (Exception e) {
            throw new RuntimeException("Internal error", e);
        }
    }

    /*
3.3.1 NTLM v1 Authentication

The following pseudocode defines the details of the algorithms used to calculate the keys used in
NTLM v1 authentication.
Note The LM and NTLM authentication versions are not negotiated by the protocol. It MUST be
configured on both the client and the server prior to authentication. The NTOWF v1 function defined
in this section is NTLM version-dependent and is used only by NTLM v1. The LMOWF v1 function
defined in this section is also version-dependent and is used only by LM and NTLM v1.
The NT and LM response keys MUST be encoded using the following specific one-way functions
where all strings are encoded as RPC_UNICODE_STRING ([MS-DTYP] section 2.3.8).


-- Explanation of message fields and variables:
--  ClientChallenge - The 8-byte challenge message generated by
    the client.
--  LmChallengeResponse - The LM response to the server challenge.
    Computed by the client.
--  NegFlg, User, UserDom - Defined in section 3.1.1.
--  NTChallengeResponse - The NT response to the server challenge.
    Computed by the client.
--  Passwd - Password of the user. If the password is longer than
    14 characters, then the LMOWF v1 cannot be computed. For LMOWF
    v1, if the password is shorter than 14 characters, it is padded
    by appending zeroes.
--  ResponseKeyNT - Temporary variable to hold the results of
    calling NTOWF().
--  ResponseKeyLM - Temporary variable to hold the results of
    calling LMGETKEY.
--  CHALLENGE_MESSAGE.ServerChallenge - The 8-byte challenge message
    generated by the server.
--
-- Functions Used:
--  Z(M)- Defined in section 6.

Define NTOWFv1(Passwd, User, UserDom) as MD4(UNICODE(Passwd))
EndDefine

Define LMOWFv1(Passwd, User, UserDom) as
    ConcatenationOf( DES( UpperCase( Passwd)[0..6],"KGS!@#$%"),
        DES( UpperCase( Passwd)[7..13],"KGS!@#$%"))
EndDefine
     
Set ResponseKeyNT to NTOWFv1(Passwd, User, UserDom)
Set ResponseKeyLM to LMOWFv1( Passwd, User, UserDom )

Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM,
CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName)
As
If (User is set to "" AND Passwd is set to "")
    -- Special case for anonymous authentication
    Set NtChallengeResponseLen to 0
    Set NtChallengeResponseMaxLen to 0
    Set NtChallengeResponseBufferOffset to 0
    Set LmChallengeResponse to Z(1)
ElseIf
    If (LM authentication)
        Set NtChallengeResponseLen to 0
        Set NtChallengeResponseMaxLen to 0
        Set NtChallengeResponseBufferOffset to 0
        Set LmChallengeResponse to DESL(ResponseKeyLM,
            CHALLENGE_MESSAGE.ServerChallenge)
    ElseIf (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg)
        Set NtChallengeResponse to DESL(ResponseKeyNT,
        MD5(ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,
            ClientChallenge))[0..7])
        Set LmChallengeResponse to ConcatenationOf{ClientChallenge,
            Z(16)}
    Else
        Set NtChallengeResponse to DESL(ResponseKeyNT,
            CHALLENGE_MESSAGE.ServerChallenge)
        If (NoLMResponseNTLMv1 is TRUE)
            Set LmChallengeResponse to NtChallengeResponse
        Else
            Set LmChallengeResponse to DESL(ResponseKeyLM,
                CHALLENGE_MESSAGE.ServerChallenge)
        EndIf
    EndIf
EndIf
     
Set SessionBaseKey to MD4(NTOWF)

     */


    /*
Define NTOWFv1(Passwd, User, UserDom) as MD4(UNICODE(Passwd))
EndDefine
     */
    public static byte[] calculateNTLMOWFv1(String domain, String username, String password) {
        return calculateMD4(password.getBytes(UNICODE_ENCODING));
    }

    /*
Define LMOWFv1(Passwd, User, UserDom) as
    ConcatenationOf( DES( UpperCase( Passwd)[0..6],"KGS!@#$%"),
        DES( UpperCase( Passwd)[7..13],"KGS!@#$%"))
EndDefine
     */
    public static byte[] calculateLMOWFv1(String domain, String username, String password) {
        try {
            byte[] pwb = password.toUpperCase().getBytes(ASCII_ENCODING);
            byte[] pwb1 = new byte[14];
            int len = password.length();
            if (len > 14)
                len = 14;
            System.arraycopy(pwb, 0, pwb1, 0, len); /* Zero padded */

            DESKeySpec dks1 = new DESKeySpec(makeDesKey(pwb1, 0));
            DESKeySpec dks2 = new DESKeySpec(makeDesKey(pwb1, 7));

            SecretKey key1 = DES_KEYFACTORY.generateSecret(dks1);
            SecretKey key2 = DES_KEYFACTORY.generateSecret(dks2);
            DES_CIPHER.init(Cipher.ENCRYPT_MODE, key1);
            byte[] out1 = DES_CIPHER.doFinal(MAGIC_KGS_CONSTANT, 0, 8);
            DES_CIPHER.init(Cipher.ENCRYPT_MODE, key2);
            byte[] out2 = DES_CIPHER.doFinal(MAGIC_KGS_CONSTANT, 0, 8);

            byte[] result = new byte[21];
            System.arraycopy(out1, 0, result, 0, 8);
            System.arraycopy(out2, 0, result, 8, 8);
            return result;
        } catch (Exception e) {
            throw new RuntimeException("Internal error", e);
        }
    }
    /* Convert a 7 byte array to an 8 byte array (for a des key with parity)
     * input starts at offset off
     */
    private static byte[] makeDesKey (byte[] input, int off) {
        int[] in = new int[input.length];
        for (int i = 0; i < in.length; i++) {
            in[i] = input[i] < 0 ? input[i] + 256 : input[i];
        }
        byte[] out = new byte[8];
        out[0] = (byte) in[off + 0];
        out[1] = (byte) (((in[off + 0] << 7) & 0xFF) | (in[off + 1] >> 1));
        out[2] = (byte) (((in[off + 1] << 6) & 0xFF) | (in[off + 2] >> 2));
        out[3] = (byte) (((in[off + 2] << 5) & 0xFF) | (in[off + 3] >> 3));
        out[4] = (byte) (((in[off + 3] << 4) & 0xFF) | (in[off + 4] >> 4));
        out[5] = (byte) (((in[off + 4] << 3) & 0xFF) | (in[off + 5] >> 5));
        out[6] = (byte) (((in[off + 5] << 2) & 0xFF) | (in[off + 6] >> 6));
        out[7] = (byte) ((in[off + 6] << 1) & 0xFF);
        return out;
    }


    public static void ntlmV1Authentication() {

    }


    /*
3.4.4 Message Signature Functions

     */

    /*
3.4.4.1 Without Extended Session Security
When Extended Session Security (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) is not
negotiated and session security (NTLMSSP_NEGOTIATE_SIGN or NTLMSSP_NEGOTIATE_SEAL) is
negotiated, the message signature for NTLM without extended session security is a 16-byte value
that contains the following components, as described by the NTLMSSP_MESSAGE_SIGNATURE
structure:
A 4-byte version-number value that is set to 1.
A 4-byte random pad.
The 4-bytes of the message's CRC32.
The 4-byte sequence number (SeqNum).
If message integrity is negotiated, the message signature is calculated as follows:
-- Input:
--  SigningKey - The key used to sign the message.
--  SealingKey - The key used to seal the message or checksum.
--  RandomPad - A random number provided by the client. Typically 0.
--  Message - The message being sent between the client and server.
--  SeqNum - Defined in section 3.1.1.
--  Handle - The handle to a key state structure corresponding to the
--  current state of the SealingKey
--
-- Output:
--  An NTLMSSP_MESSAGE_SIGNATURE structure whose fields are defined
    in section 2.2.2.9.
--  SeqNum - Defined in section 3.1.1.
--
-- Functions used:
--  ConcatenationOf() - Defined in Section 6.
--  RC4() - Defined in Section 6.
--  CRC32() - Defined in Section 6.
Define MAC(Handle, SigningKey, SeqNum, Message) as
    Set NTLMSSP_MESSAGE_SIGNATURE.Version to 0x00000001
    Set NTLMSSP_MESSAGE_SIGNATURE.Checksum to CRC32(Message)
    Set NTLMSSP_MESSAGE_SIGNATURE.RandomPad RC4(Handle, RandomPad)
    Set NTLMSSP_MESSAGE_SIGNATURE.Checksum to RC4(Handle, NTLMSSP_MESSAGE_SIGNATURE.Checksum)
    Set NTLMSSP_MESSAGE_SIGNATURE.SeqNum to RC4(Handle, 0x00000000)
    If (connection oriented)
        Set NTLMSSP_MESSAGE_SIGNATURE.SeqNum to
            NTLMSSP_MESSAGE_SIGNATURE.SeqNum XOR SeqNum
        Set SeqNum to SeqNum + 1
    Else
        Set NTLMSSP_MESSAGE_SIGNATURE.SeqNum to
            NTLMSSP_MESSAGE_SIGNATURE.SeqNum XOR
            (application supplied SeqNum)
    Endif
    Set NTLMSSP_MESSAGE_SIGNATURE.RandomPad to 0
EndDefine

     */


    /*
3.4.4.2 With Extended Session Security
When Extended Session Security (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) is
negotiated and session security (NTLMSSP_NEGOTIATE_SIGN or NTLMSSP_NEGOTIATE_SEAL) is
negotiated, the message signature for NTLM with extended session security is a 16-byte value that
contains the following components, as described by the NTLMSSP_MESSAGE_SIGNATURE structure:
A 4-byte version-number value that is set to 1.
The first eight bytes of the message's HMAC_MD5.
The 4-byte sequence number (SeqNum).
If message integrity is negotiated, the message signature is calculated as follows:
-- Input:
--
SigningKey - The key used to sign the message.
--
SealingKey - The key used to seal the message or checksum.
--
Message - The message being sent between the client and server.
--
SeqNum - Defined in section 3.1.1.
--
Handle - The handle to a key state structure corresponding to the
--
current state of the SealingKey
--
-- Output:
--
An NTLMSSP_MESSAGE_SIGNATURE structure whose fields are defined
in section 2.2.2.9.
--
SeqNum - Defined in section 3.1.1.
--
-- Functions used:
--
ConcatenationOf() - Defined in Section 6.
--
RC4() - Defined in Section 6.
--
HMAC_MD5() - Defined in Section 6.
Define MAC(Handle, SigningKey, SeqNum, Message) as
Set NTLMSSP_MESSAGE_SIGNATURE.Version to 0x00000001
Set NTLMSSP_MESSAGE_SIGNATURE.Checksum to
HMAC_MD5(SigningKey,
ConcatenationOf(SeqNum, Message))[0..7]
Set NTLMSSP_MESSAGE_SIGNATURE.SeqNum to SeqNum
Set SeqNum to SeqNum + 1
EndDefine


     */

    /*
If a key exchange key is negotiated, the message signature for the NTLM security service provider is
the same as in the preceding description, except the 8 bytes of the HMAC_MD5 are encrypted with
RC4, as follows:
Define MAC(Handle, SigningKey, SeqNum, Message) as
Set NTLMSSP_MESSAGE_SIGNATURE.Version to 0x00000001
Set NTLMSSP_MESSAGE_SIGNATURE.Checksum to RC4(Handle,
HMAC_MD5(SigningKey, ConcatenationOf(SeqNum, Message))[0..7])
Set NTLMSSP_MESSAGE_SIGNATURE.SeqNum to SeqNum
Set SeqNum to SeqNum + 1
EndDefine

     */


    /*
3.4.5.1 KXKEY
If NTLM v1 is used and extended session security is not negotiated, the 128-bit key exchange key
value is calculated as follows:
-- Input:
--  SessionBaseKey - A session key calculated from the user's
    password.
--  LmChallengeResponse - The LM response to the server challenge.
    Computed by the client.
--  NegFlg - Defined in section 3.1.1.
--
-- Output:
--  KeyExchangeKey - The Key Exchange Key.
--
-- Functions used:
--  ConcatenationOf() - Defined in Section 6.
--  DES() - Defined in Section 6.

Define KXKEY(SessionBaseKey, LmChallengeResponse, ServerChallenge) as
If ( NTLMSSP_NEGOTIATE_LMKEY flag is set in NegFlg)
    Set KeyExchangeKey to ConcatenationOf(DES(LMOWF[0..6],
        LmChallengeResponse[0..7]),
        DES(ConcatenationOf(LMOWF[7], 0xBDBDBDBDBDBD),
        LmChallengeResponse[0..7]))
Else
    If ( NTLMSSP_REQUEST_NON_NT_SESSION_KEY flag is set in NegFlg)
        Set KeyExchangeKey to ConcatenationOf(LMOWF[0..7], Z(8)),
    Else
        Set KeyExchangeKey to SessionBaseKey
    Endif
Endif
EndDefine
    */

    /*
If NTLM v1 is used and extended session security is negotiated, the key exchange key value is
calculated as follows:
-- Input:
--  SessionBaseKey - A session key calculated from the user's
    password.
--  ServerChallenge - The 8-byte challenge message
    generated by the server.
--  LmChallengeResponse - The LM response to the server challenge.
    Computed by the client.
--
-- Output:
--  KeyExchangeKey - The Key Exchange Key.
--
-- Functions used:
--  ConcatenationOf() - Defined in Section 6.
--  HMAC_MD5() - Defined in Section 6.

Define KXKEY(SessionBaseKey, LmChallengeResponse, ServerChallenge) as
    Set KeyExchangeKey to HMAC_MD5(SessionBaseKey, ConcatenationOf(ServerChallenge,
        LmChallengeResponse [0..7]))
EndDefine

     */


    /*
3.4.5.2 SIGNKEY
If extended session security is not negotiated (section 2.2.2.5), then no signing keys are available
and message signing is not supported.
If extended session security is negotiated, the signing key is a 128-bit value that is calculated as
follows from the random session key and the null-terminated ASCII constants shown.
-- Input:
--  RandomSessionKey - A randomly generated session key.
--  NegFlg - Defined in section 3.1.1.
--  Mode - An enum that defines the local machine performing
    the computation.
    Mode always takes the value "Client" or "Server.
--
-- Output:
--  SignKey - The key used for signing messages.
--
-- Functions used:
--  ConcatenationOf(), MD5(), NIL - Defined in Section 6.

Define SIGNKEY(NegFlg, RandomSessionKey, Mode) as
If (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg)
    If (Mode equals "Client")
        Set SignKey to MD5(ConcatenationOf(RandomSessionKey,
            "session key to client-to-server signing key magic constant"))
    Else
        Set SignKey to MD5(ConcatenationOf(RandomSessionKey,
            "session key to server-to-client signing key magic constant"))
    Endif
Else
    Set SignKey to NIL
Endif
EndDefine

     */
    public enum SignkeyMode {
        client("session key to client-to-server signing key magic constant"),
        server("session key to server-to-client signing key magic constant");

        public final String magicString;

        SignkeyMode(String magicString) {
            this.magicString = magicString;
        }
    }

    public void signkey(SignkeyMode mode, byte[] randomSessionKey) {
        
    }

    /*
3.4.5.3 SEALKEY
The sealing key function produces an encryption key from the random session key and the null-
terminated ASCII constants shown.
If extended session security is negotiated, the sealing key has either 40, 56, or 128 bits of
entropy stored in a 128-bit value.
If extended session security is not negotiated, the sealing key has either 40 or 56 bits of entropy
stored in a 64-bit value.
Note The MD5 hashes completely overwrite and fill the 64-bit or 128-bit value.
-- Input:
--  RandomSessionKey - A randomly generated session key.
--  NegFlg - Defined in section 3.1.1.
--  Mode - An enum that defines the local machine performing
    the computation.
    Mode always takes the value "Client" or "Server.
--
-- Output:
--  SealKey - The key used for sealing messages.
--
-- Functions used:
--  ConcatenationOf(), MD5() - Defined in Section 6.
Define SEALKEY(NegotiateFlags, RandomSessionKey, Mode) as
If (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg)
    If ( NTLMSSP_NEGOTIATE_128 is set in NegFlg)
        Set SealKey to RandomSessionKey
    ElseIf ( NTLMSSP_NEGOTIATE_56 flag is set in NegFlg)
        Set SealKey to RandomSessionKey[0..6]
    Else
        Set SealKey to RandomSessionKey[0..4]
    Endif
    If (Mode equals "Client")
        Set SealKey to MD5(ConcatenationOf(SealKey, "session key to client-to-server sealing key magic constant"))
    Else
        Set SealKey to MD5(ConcatenationOf(SealKey, "session key to server-to-client sealing key magic constant"))
    Endif
ElseIf (NTLMSSP_NEGOTIATE_56 flag is set in NegFlg)
    Set SealKey to ConcatenationOf(RandomSessionKey[0..6], 0xA0)
Else
    Set SealKey to ConcatenationOf(RandomSessionKey[0..4], 0xE5, 0x38, 0xB0)
Endif
EndDefine

     */
}
